参考：[官方文档](https://cn.vuejs.org/guide/introduction.html)

# 1 基础

## 1.1 创建一个应用

createApp允许在同一个页面中创建多个共存的 Vue 应用，而且每个应用都拥有自己的用于配置和全局资源的作用域。

## 1.2 模板语法

template标签里，如何与script标签中定义的变量、方法交互。

## 1.3 响应式基础

* 响应式代理：给状态变量赋了普通变量的值，状态变量是该普通变量的一个代理，并不===普通变量
* 有状态的方法被多个组件共享时的解决办法

>Vue 在组件实例上暴露的内置 API 使用 $ 作为前缀。它同时也为内部属性保留 _ 前缀。因此，你应该避免在顶层 data 上使用任何以这些字符作前缀的属性。

## 1.4 计算属性

可缓存的计算结果：依赖状态变量

## 1.5 类与样式绑定

template标签里，应用于样式的模板语法，以及组件上层的样式传到下层归属于谁。

## 1.6 条件渲染

template标签的if else for

## 1.7 列表渲染

v-for

## 1.8 事件处理

## 1.9 表单输入绑定

## 1.10 生命周期

重要

## 1.11 侦听器

监听状态变量的变化

## 1.12 模板引用

获得dom元素或组件实例的引用。

## 1.13 组件基础

* 组件的定义与使用
* 父子组件的通信：父传子：props，子传父：子调用父的事件
* 插槽slot：子组件接收父组件传的模板内容
* 组件来回切换显示
* html不区分大小写，如果要在DOM中写模板，以下几种格式需要转换为等价的 kebab-case (短横线连字符) 形式：
    * PascalCase 形式的组件名称
    * camelCase 形式的 prop 名称
    * v-on 的事件名称
* 在DOM中写模板，还会受到其它元素类型的限制，table下只能放tr，ul下只能放li，如果table放自定义的组件会报错，不过有解决办法。

最后两点不用考虑，因为基本不会在DOM中写模板。

# 2 深入组件

## 2.1 注册

全局组件和局部组件的注册。

## 2.2 props

传递props的细节：

* 在子中用定义方式区分开父往子传的是props还是透传attribute
* 父传子时，父用kebab-case形式，子用camelCase形式声明
* 除了字符串，其它类型的值都要用v-bind传到子里
* 不应该在子中修改父传入的props的值
* 子中可以对父传入的props进行类型校验

## 2.3 事件

* 父子监听
    * 没有冒泡机制：父组件只能监听直接子组件的事件
    * 父在监听时可以收到子给父的参数
* defineEmits：用emit函数触发原生的事件(click...)，这个时候可以在defineEmits中对click进行验证
* 对v-model的增强

## 2.4 透传Attributes

一、除了声明为`props的attribute`或`emits的v-on 事件监听器`外的属性：

* attribute: class, style, id
* 普通v-on

二、禁用子组件单根节点的默认继承，然后自定义让子组件的哪个节点使用
三、子组件多根节点需要显式声明哪一个继承
四、该Attributes不是响应式

## 2.5 插槽

更详细的用法

## 2.6 依赖注入

很妙，为了避免某个子组件从想要获得某个很遥远的父组件的props，从上往下逐级传递的笨方法，

提供了一个相当于在父组件维护的一个变量，其不管多深的子组件都可以对该变量进行读操作，写操作定义在父组件中，可以把写操作开放给子组件，从而实现了子组件也可以对该变量进行修改的操作。

## 2.7 异步组件

仅在页面需要它渲染时才会调用加载内部实际组件的函数。它会将接收到的 props 和插槽传给内部组件，所以你可以使用这个异步的包装组件无缝地替换原始组件，同时实现延迟加载。

# 3 逻辑复用

## 3.1 组合式函数

* 组合式 API：有状态逻辑的方法如何在其他多个组件中被复用
    * 示例：将请求包装成组合式api，接受不同的URL参数，并使用watchEffect让每次URL变化时都重新请求。
* 组合式API入参与返回值的最佳实践以及使用限制

我就觉得和REACT Hooks很像，然后官方说法是：
>Vue 的组合式函数是基于 Vue 细粒度的响应性系统，这和 React hooks 的执行模型有本质上的不同。这一话题在[组合式 API 的常见问题](https://cn.vuejs.org/guide/extras/composition-api-faq.html#comparison-with-react-hooks)中有更细致的讨论。

## 3.2 自定义指令

重用3大块：
* 组件：可重用模块
* 组合式函数：可重用有状态的逻辑
* 自定义指令：可重用涉及普通元素的底层 DOM 访问的逻辑（如官方提供的v-model 或 v-show）
    * 只有当所需功能只能通过直接的 DOM 操作来实现时，才应该使用自定义指令（如input的自动聚焦）。其他情况下应该尽可能地使用 v-bind 这样的内置指令来声明式地使用模板，这样更高效，也对服务端渲染更友好。

## 3.3 插件

插件的编写、安装以及使用，例子中给了个超简单的国际化插件编写和使用示例。

# 4 内置组件

## 4.1 Transition

过渡：会在一个元素或组件进入和离开 DOM 时应用动画。

动画所用到的 CSS 属性大多是 transform 和 opacity，用这些属性制作动画非常高效，因为：

* 他们在动画过程中不会影响到 DOM 结构，因此不会每一帧都触发昂贵的 CSS 布局重新计算。

* 大多数的现代浏览器都可以在执行 transform 动画时利用 GPU 进行硬件加速。

相比之下，像 height 或者 margin 这样的属性会触发 CSS 布局变动，因此执行它们的动画效果更昂贵，需要谨慎使用。我们可以在 [CSS-Triggers](https://csstriggers.com/) 这类的网站查询哪些属性会在执行动画时触发 CSS 布局变动。

## 4.2 TransitionGroup

TransitionGroup 会在一个 v-for 列表中的元素或组件被插入、移动、或移除时应用动画。

**必用**

## 4.3 KeepAlive

默认情况下，一个组件实例在被替换掉后会被销毁。这会导致它丢失其中所有已变化的状态 —— 当这个组件再一次被显示时，会创建一个只带有初始状态的新实例。

KeepAlive 是一个内置组件，它的功能是在多个组件间动态切换时缓存被移除的组件实例。

## 4.4 Teloport

瞬移：可以将一个组件内部的一部分模板“传送”到该组件的 DOM 结构外层的位置去。

通常用作模态框的实现。

## 4.5 Suspense

是一个还没确定下的功能，从名字上看是要等待父组件中依赖的子组件内的异步操作完成，父组件再做出操作。

具体的没看。

# 5 应用规模化

## 5.1 单文件组件

就是用vue写的一个组件对应着一个文件的写法，然后使用所谓的构建工具将这些文件整合成浏览器能访问的网页。

* 单页面应用 (SPA)
* 静态站点生成 (SSG)：有点疑问，如果有和后端交互的页面，生成静态页面后的样子是啥？
* 任何值得引入构建步骤以获得更好的开发体验 (DX) 的项目：不知道是啥玩意

## 5.2 工具链

[下载浏览器开发者插件](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd)：Vue 的浏览器开发者插件使我们可以浏览一个 Vue 应用的组件树，查看各个组件的状态，追踪状态管理的事件，还可以进行组件性能分析。

## 5.3 路由

Vue 很适合用来构建单页面应用。对于大多数此类应用，都推荐使用官方支持的[路由库](https://github.com/vuejs/router)。要了解更多细节，请查看 [Vue Router 的文档](https://router.vuejs.org/zh/)。

## 5.4 状态管理

在`2.6 依赖组件`中已经讲过了。

## 5.5 测试

比较复杂，需要的时候再看吧：

* 单元测试：检查给定函数、类或组合式函数的输入是否产生预期的输出或副作用。
* 组件测试：检查你的组件是否正常挂载和渲染、是否可以与之互动，以及表现是否符合预期。这些测试比单元测试导入了更多的代码，更复杂，需要更多时间来执行。
* 端到端测试：检查跨越多个页面的功能，并对生产构建的 Vue 应用进行实际的网络请求。这些测试通常涉及到建立一个数据库或其他后端。

## 5.6 服务端渲染 (SSR)

强烈建议先看这篇文档[《SSG、SSR、CSR的区别》](https://blog.csdn.net/qq_24147051/article/details/126308367)的解释，再看官方文档

### 5.6.1 个人理解

作为一个JAVA程序员，感觉历史是一个轮回，

1. 最开始的JAVA WEB端，是前端页面和后端逻辑在一起，用户在浏览器端访问JSP/JSF页面时，由JAVA内部将页面和逻辑处理完成后，再返回给浏览器端一个页面
2. 然后是前后端分离时期，那时候还没有各种前端框架，顶多有什么BootStrap和JQuery便于快速开发前端页面的框架，然后用户在浏览器访问前端得到页面后，发现有JS需要和后端交互，然后再次通过JS访问后端获得数据改变DOM，呈现最终的页面
3. 到现在，出现了各种各样的前端框架，不是像第2点只是单纯地开发HTML页面，而是编写框架规定的文件格式，然后使用框架提供的构建工具将编写的文件转为HTML，仍然是前后端分离，但是开始考虑效率的问题，因此出现了CSR、SSR的讨论。

在我看来SSR就是第1点，CSR就是第2点，现在的前端程序员觉得在前端实现SSR是一种更优的选择，只是会比较占用服务器资源。

### 5.6.2 例子环境

具体一个例子就是：

>我解释时就不说什么客户端、服务端了，我刚了解的时候感觉让人一脸懵逼，不知道哪个是哪个

首先在远程服务器上部署了两个进程，一个运行的是前端页面的代码(比如说是用vue写的)，一个运行的是后端代码。

然后本地的浏览器与远程服务器上的前端进程进行交互，前端进程和后端进程进行交互(所谓的前后端分离)。

### 5.6.3 CSR

那么现在来说CSR，vue有个命令，可以把写的整个应用打包生成HTML页面，那么现在远程服务器上的前端进程有一个HTML WEB容器，其中就只是单纯地运行了这个HTML页面

步骤：

1. 浏览器请求远程服务器的前端进程，获得HTML和JS页面到本地
2. 浏览器发现HTML页面有JS，JS要改DOM，或者要访问远程服务器后端获得数据后更改DOM
3. 然后本地的浏览器又发起到远程服务器后端进程的请求，获得数据后更改DOM

可以发现不断发起从本地到远程的请求，要来回好多次，在浏览器本地，也就是用户才能看到最终的画面，如果网络慢的话，用户肯定超不爽。

### 5.6.4 SSR

当然他们说的SSR和我在5.6.1上说的还是有些不一样，

前端进程还是以vue举例，这次不直接生成HTML页面了，而是在使用vue写好可以生成HTML页面（里面可能包含请对后端进程的请求，一并把数据通过JS填充到HTML里）的功能，然后基于nodejs启动该前端应用，启动完成后也就是前面说的前端进程。

这时的步骤则变为：

1. 浏览器请求远程服务器的前端进程，获得HTML，这就是最终到用户浏览器上最终展示的HTML页面，怎么生成的呢：
    1.1 前端进程会根据用户浏览器的请求，去自动获取要返回的页面，
    1.2 如果这个页面上有与后端进程交互的请求，那么直接去请求数据
    1.3 返回数据后，重新构造HTML并返回给浏览器端

理所当然的，在远程上的前端和后端的交互数据的速度肯定远比本地到远程的快，因此用户会发现一下就看到完整的页面了。

### 5.6.5 SSG

这就是和CSR一样生成静态页面了，不过夹杂了一点SSR的东西，在生成静态页面时，会先去把那些要和后端进程交互的数据拿到手然后生成贼多静态页面，

这样的话如果应用有新的数据产生，就必须得重新生成静态页面并部署，才能看到新的数据。